//// Code generated by parrot. DO NOT EDIT.
////

import gleam/dynamic/decode
import gleam/option.{type Option}
import parrot/dev

pub fn insert_pipe_settings(
  id id: BitArray,
  node node: String,
  namespace namespace: String,
  flags flags: Int,
) {
  let sql =
    "INSERT INTO pipe_settings (
  id, node, namespace, flags
) VALUES (
  ?, ?, ?, ?
)"
  #(sql, [
    dev.ParamBitArray(id),
    dev.ParamString(node),
    dev.ParamString(namespace),
    dev.ParamInt(flags),
  ])
}

pub type LatestPipeSettings {
  LatestPipeSettings(id: BitArray, node: String, namespace: String, flags: Int)
}

pub fn latest_pipe_settings(namespace namespace: String) {
  let sql =
    "SELECT id, node, namespace, flags FROM pipe_settings
WHERE namespace = ?
ORDER BY id DESC
LIMIT 1"
  #(sql, [dev.ParamString(namespace)], latest_pipe_settings_decoder())
}

pub fn latest_pipe_settings_decoder() -> decode.Decoder(LatestPipeSettings) {
  use id <- decode.field(0, decode.bit_array)
  use node <- decode.field(1, decode.string)
  use namespace <- decode.field(2, decode.string)
  use flags <- decode.field(3, decode.int)
  decode.success(LatestPipeSettings(id:, node:, namespace:, flags:))
}

pub type InsertPipeEntry {
  InsertPipeEntry(col_0: Int)
}

pub fn insert_pipe_entry(
  id id: BitArray,
  node node: String,
  pipe pipe: String,
  method method: Option(String),
  headers headers: Option(String),
  body body: Option(BitArray),
  sender sender: Option(String),
  namespace namespace: String,
) {
  let sql =
    "INSERT INTO pipe_entries (
  id, node, pipe, method, headers, body, sender
)
SELECT ?1, ?2, ?3, ?4, ?5, ?6, ?7
WHERE (
  SELECT (flags & 1) persisted
  FROM pipe_settings 
  WHERE pipe_settings.namespace = ?8
  ORDER BY id DESC
  LIMIT 1
) = 1
RETURNING 1"
  #(
    sql,
    [
      dev.ParamBitArray(id),
      dev.ParamString(node),
      dev.ParamString(pipe),
      dev.ParamNullable(option.map(method, fn(v) { dev.ParamString(v) })),
      dev.ParamNullable(option.map(headers, fn(v) { dev.ParamString(v) })),
      dev.ParamNullable(option.map(body, fn(v) { dev.ParamBitArray(v) })),
      dev.ParamNullable(option.map(sender, fn(v) { dev.ParamString(v) })),
      dev.ParamString(namespace),
    ],
    insert_pipe_entry_decoder(),
  )
}

pub fn insert_pipe_entry_decoder() -> decode.Decoder(InsertPipeEntry) {
  use col_0 <- decode.field(0, decode.int)
  decode.success(InsertPipeEntry(col_0:))
}

pub type PipeEntriesByPipe {
  PipeEntriesByPipe(
    id: BitArray,
    method: Option(String),
    headers: Option(String),
    body: Option(BitArray),
  )
}

pub fn pipe_entries_by_pipe(
  pipe pipe: String,
  limit limit: Int,
  offset offset: Int,
) {
  let sql =
    "SELECT id, method, headers, body
FROM pipe_entries
WHERE pipe = ?
ORDER BY id DESC
LIMIT ?
OFFSET ?"
  #(
    sql,
    [dev.ParamString(pipe), dev.ParamInt(limit), dev.ParamInt(offset)],
    pipe_entries_by_pipe_decoder(),
  )
}

pub fn pipe_entries_by_pipe_decoder() -> decode.Decoder(PipeEntriesByPipe) {
  use id <- decode.field(0, decode.bit_array)
  use method <- decode.field(1, decode.optional(decode.string))
  use headers <- decode.field(2, decode.optional(decode.string))
  use body <- decode.field(3, decode.optional(decode.bit_array))
  decode.success(PipeEntriesByPipe(id:, method:, headers:, body:))
}

pub fn create_account(
  id id: BitArray,
  node node: String,
  updated_at updated_at: Int,
) {
  let sql =
    "INSERT INTO accounts (id, node, updated_at)
VALUES (?1, ?2, ?3)"
  #(sql, [
    dev.ParamBitArray(id),
    dev.ParamString(node),
    dev.ParamInt(updated_at),
  ])
}

pub fn add_key_to_account(
  id id: BitArray,
  node node: String,
  updated_at updated_at: Int,
  account_id account_id: BitArray,
  jwk jwk: Option(BitArray),
) {
  let sql =
    "INSERT INTO account_keys (id, node, updated_at, account_id, jwk)
VALUES (?1, ?2, ?3, ?4, ?5)"
  #(sql, [
    dev.ParamBitArray(id),
    dev.ParamString(node),
    dev.ParamInt(updated_at),
    dev.ParamBitArray(account_id),
    dev.ParamNullable(option.map(jwk, fn(v) { dev.ParamBitArray(v) })),
  ])
}

pub fn remove_key_from_account(
  id id: BitArray,
  node node: String,
  updated_at updated_at: Int,
  account_id account_id: BitArray,
) {
  let sql =
    "INSERT INTO account_keys (id, node, updated_at, account_id, jwk)
VALUES (?1, ?2, ?3, ?4, NULL)"
  #(sql, [
    dev.ParamBitArray(id),
    dev.ParamString(node),
    dev.ParamInt(updated_at),
    dev.ParamBitArray(account_id),
  ])
}

pub type KeysForAccount {
  KeysForAccount(id: BitArray, jwk: Option(BitArray))
}

pub fn keys_for_account(account_id account_id: BitArray) {
  let sql =
    "SELECT id, jwk FROM (
  SELECT id, jwk, MAX(updated_at)
  FROM account_keys
  WHERE account_id = ?1
  GROUP BY id
) WHERE jwk IS NOT NULL"
  #(sql, [dev.ParamBitArray(account_id)], keys_for_account_decoder())
}

pub fn keys_for_account_decoder() -> decode.Decoder(KeysForAccount) {
  use id <- decode.field(0, decode.bit_array)
  use jwk <- decode.field(1, decode.optional(decode.bit_array))
  decode.success(KeysForAccount(id:, jwk:))
}

pub type FetchAccountKey {
  FetchAccountKey(jwk: Option(BitArray), account_id: BitArray)
}

pub fn fetch_account_key(id id: BitArray) {
  let sql =
    "SELECT jwk, account_id
FROM account_keys
WHERE id = ?1
ORDER BY id DESC
LIMIT 1"
  #(sql, [dev.ParamBitArray(id)], fetch_account_key_decoder())
}

pub fn fetch_account_key_decoder() -> decode.Decoder(FetchAccountKey) {
  use jwk <- decode.field(0, decode.optional(decode.bit_array))
  use account_id <- decode.field(1, decode.bit_array)
  decode.success(FetchAccountKey(jwk:, account_id:))
}
